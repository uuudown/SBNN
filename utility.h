/** @file utility.h
 *  @brief Utility functions.
 *
 *  @author Ang Li (PNNL)
 *
*/

#ifndef UTILITY_H
#define UTILITY_H

#include <sys/time.h>



//================ Type Definition ===============
typedef unsigned long long ullong;
typedef unsigned char uchar;

//================ Macro Definition ===============
#define BITWIDTH 32
#define LOG_BITWIDTH 5
#define CEIL(X) (((X)+BITWIDTH-1)>>LOG_BITWIDTH)
#define FEIL(X) ((((X)+BITWIDTH-1)>>LOG_BITWIDTH)<<LOG_BITWIDTH)

#define BITWIDTH64 64
#define LOG_BITWIDTH64 6
#define CEIL64(X) (((X)+BITWIDTH64-1)>>LOG_BITWIDTH64)
#define FEIL64(X) ((((X)+BITWIDTH64-1)>>LOG_BITWIDTH64)<<LOG_BITWIDTH64)

#define GET_LANEID unsigned laneid; asm("mov.u32 %0, %%laneid;":"=r"(laneid)); \
    unsigned warpid; asm("mov.u32 %0, %%warpid;":"=r"(warpid)); 

//Prefetching for L1, L2 and Tex caches
#define PREFETCH_L1(x) asm("prefetch.global.L1 [%0];"::"l"(&x));
#define PREFETCH_L2(x) asm("prefetch.global.L2 [%0];"::"l"(&x));
#define PREFETCH_L1T(x) __ldg((int*)&x); 

//Bypassing for float, unsigned and ullong
#define BYPASS_FT(x,y) asm("ld.global.cg.f32 %0, [%1];":"=f"(x):"l"(&y));
#define BYPASS_US(x,y) asm("ld.global.cg.u32 %0, [%1];":"=r"(x):"l"(&y));
#define BYPASS_ULL(x,y) asm("ld.global.cg.u64 %0, [%1];":"=l"(x):"l"(&y));

//Start Timer
#define START_TIMER cudaEvent_t start, stop;\
    cudaEventCreate(&start);\
    cudaEventCreate(&stop);\
    cudaEventRecord(start);

//Stop Timer
#define STOP_TIMER cudaEventRecord(stop); \
    cudaEventSynchronize(stop); \
    float milliseconds = 0; \
    cudaEventElapsedTime(&milliseconds, start, stop); \
    printf("\n============================\n"); \
    printf("Inference_Time: %.3f ms.",milliseconds);\
    printf("\n============================\n");

//Start Kernel Timer
#define SET_KERNEL_TIMER ullong t0 = clock64();
//Stop Kernel Timer
#define TICK_KERNEL_TIMER(X)  grid.sync(); \
    if (threadIdx.x==0 && blockIdx.x == 0) printf("Layer-%s takes %lld cycles.\n", (X)->name, clock64()-t0);


//================ CPU utility functions ===============

/** @brief CPU side timer based on gettimeofday.
 *
 *  Not very reliable when measuing GPU kernel time. Should use cudaEvents instead.
 *
 *  @return Current time stamp.
 */
double getRealTimer()
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    tv.tv_sec -= 1254348000;
    return (tv.tv_sec * 1000000 + tv.tv_usec);
}

/** @brief Load params from network configuration file.
 *
 *  Load weights, bias, or batch-normal parameters from an SBNN network configuration file.
 *
 *  @param cf SBNN network configuration file generated by SBNN training framework.
 *  @param array Array to load data into.
 *  @param array_size Number of parameters to fetch into the array.
 *
 *  @return Void.
 */
void launch_array(FILE* cf, float* array, unsigned array_size)
{
    if (cf == NULL)
    {
        fprintf(stderr, "NULL pointer to the network configuration file.\n");
        exit(1);
    }
    for (int i=0; i<array_size; i++) 
        fscanf(cf, "%f", &array[i]); 
}

/** @brief Compare inference output with labels
 *
 *
 *  @param prediction Inference output in one-hot format
 *  @param labels Image labels
 *  @param categories Number of classification categories
 *  @param batch Batch size
 *
 *  @return Void.
 */
void validate_prediction(float* prediction, unsigned* labels, const unsigned categories, const unsigned batch)
{
    printf("======Label======\n");
    for(int i=0; i<batch; i++) printf("%u ",labels[i]);
    printf("\n=====Predict=======\n");
    int corrects = 0;
    int corrects_top5 = 0;
    for (int i=0; i<batch; i++)
    {
        int pos = 0;
        float max = prediction[i*categories];

        float max1 = prediction[i*categories];
        float max2 = prediction[i*categories];
        float max3 = prediction[i*categories];
        float max4 = prediction[i*categories];
        int pos1 = 0;
        int pos2 = 0;
        int pos3 = 0;
        int pos4 = 0;


        for (int j=0; j<categories; j++)
        {
            float val = prediction[i*categories+j];
            if (val>max)
            {
                max = val; pos = j;
            }
            else if (val > max1)
            {
                max1 = val; pos1 = j;
            }
            else if (val > max2)
            {
                max2 = val; pos2 = j;
            }
            else if (val > max3)
            {
                max3 = val; pos3 = j;
            }
            else if (val > max4)
            {
                max4 = val; pos4 = j;
            }
        }
        printf("%d ", pos);
        if (pos == labels[i]) corrects += 1;
        if (pos == labels[i] || pos1 == labels[i] || pos2 == labels[i]
                || pos3 == labels[i] || pos4 == labels[i] ) 
        {
            corrects_top5 += 1;
        }
    }
    printf("\n=====Batch Accuracy:%d=======\n", batch);
    printf("Top-1:%f\%\n",float(corrects)/batch*100);
    printf("Top-5:%f\%\n",float(corrects_top5)/batch*100);
}

//================ GPU utility functions ===============

/** @brief For efficient 64-bit store in GPU.
 *
 *  To efficiently store 64-bit data to global memory.
 *
 *  @return Void.
 */
template <typename T>
__device__ __inline__ void store64(const void* addr, T a, T b)
{
    *((float2*)addr) = make_float2(*(float*)(&a),*(float*)(&b));
}

/** @brief For efficient 128-bit store in GPU.
 *
 *  To efficiently store 128-bit data to global memory.
 *
 *  @return Void.
 */
template <typename T>
__device__ __inline__ void store128(const void* addr, T a, T b, T c, T d)
{
    *((float4*)addr) = make_float4(*(float*)(&a),*(float*)(&b),*(float*)(&c),*(float*)(&d));
}


/**
 * CUDA Error report function. This is for debugging purposes.
 *
 * @param code Error code returned by CUDA driver or runtime.
 * @param file File to be written in for the error message.
 * @param line Error position with line number.
 * @param abort Whether abort from the running.
 */
#define CUDA_SAFE_CALL(ans) { gpuAssert((ans), __FILE__, __LINE__); }
inline void gpuAssert(cudaError_t code, const char *file, int line, bool abort=true)
{
    if (code != cudaSuccess)
    {
        fprintf(stderr,"GPU_ERROR: %s %s %d\n", cudaGetErrorString(code), file, line);
        if (abort) exit(code);
    }
}












#endif
